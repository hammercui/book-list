# 主线程子线程切换
> go没有线程，但是有goroutine，所谓的主线程，指app启动后，主逻辑所在的goroutine，一般是死循环，用select获得channel消息，或者滴答。在用一个goroutine，容易处理event的时序，模拟真实的游戏世界。

> 使用到了两个库，timer,post，

## timer库
>基于heap的定时器模拟

* func AddCallback(d time.Duration, callback CallbackFunc) *Timer:定时一次性回调
* func AddTimer(d time.Duration, callback CallbackFunc) *Timer:设置一个定时触发的回调，这个回调将在d时间后第一次触发，以后每隔d时间重复触发，并调用callback函数
* func Tick() 
```
// 对定时器模块进行一次Tick
// 
// 一般上层模块需要在一个主线程的goroutine里按一定的时间间隔不停的调用Tick函数，从而确保timer能够按时触发，并且
// 所有Timer的回调函数也在这个goroutine里运行。
// 意思是上面两个的定时器正常触发，需要定时调用Tick()
```
* func StartTicks(tickInterval time.Duration): 创建一个goroutine对定时器模块进行定时的Tick,当不执行上一个操作时，要使用本函数去定时tick,但是这种情况下；回调就在这个协程里执行了，不像上一个操作，回调在主线程执行

## post 库
>子线程Post入队，主线程出队并执行

type PostCallback func()

* func Post(f PostCallback): 入参为需要在主线程调用的回调函数，没有入参，在主线程的tick里统一调用
* func Tick()：在主线程里定时执行，pop出需要调用的函数
