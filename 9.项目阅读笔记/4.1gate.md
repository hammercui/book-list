# gate解析



### 综述 gate->dispatcher->game
>需要tcp,kcp,websocket,http服务
>gateService缩写为gate
>dispatcherService缩写为dispatcher
>gamaeService缩写为game

```mermaid
graph TB
    a0((gate.main))--提供给client的服务-->a[gate.run]
    a-->b[子线程websocketConn,tcpConn,kcpConn]
    b-.client接入.->c[子线程gate.handleClientConnection]
    c-->d[newClientProxy]
    d--存入client连接池-->e[回主线程gate.onNewClientProxy]
    e--SendNotifyClientConnected-->q
    q-->f[dispatcher.handleNotifyClientConnected]
    f-->g[选择合适的game服chooseGameForBootEntity]
    g-.dispatchPacket.->h[gameService.HandleNotifyClientConnected]
    d-->i[ClientProxy.server]
    i-.接收客户端数据包入队.->j[clientPacketQueue]
    a-->k[mainRoutine]
    k-.循环读取.->j
    j-->l[handleClientProxyPacket]
    l-->l1[同步坐标与旋转消息]
    l-->l2[rpc消息]
    a0--连接dispatcher服务-->m[dispatchercluster.Initialize]
    m-.delegate获得包.->n[gate.dispatcherClientPacketQueue]
    k-.循环读取.->n
    n-->o[gate.handleDispatcherClientPacket]
    o-->p((client))
    l1-->q((dispatcher服务))
    l2-->q


```

* 收到client的位置消息，定时5ms一次性同步给所有的dispatcher。根据entity确定属于哪个dispatcher

* 


## 问题

 ### 1 gate是怎么找到目标dispatcher？

跟game类似，通过dispatchercluster主动连接所有dispatcher,存储连接池。

计算entityId的int值，除以dispatcher总数取余，获得dispatcher序号，一个game会连接所有的dispatcher，然后平均分配dispatcher。

也就说说并没有根据dispatcher真实的负载去选择，dispatcher就是一个简单的proxy代理。

```
func SelectByEntityID(entityid common.EntityID) *dispatcherclient.DispatcherClient {
	idx := hashEntityID(entityid) % dispatcherNum
	return dispatcherConns[idx].GetDispatcherClientForSend()
}
```

 ### 2 gate是怎么找到目标client的?

 client在接入gate时，gate会对每个连接分配一个clientProxy对象,该对象包含一个唯一的clientid，`common.GenClientID()`生成，以键值对的形式缓存gateService.clientProxies

 当收到dispatcher的包时，packet会携带clientId, 根据clientId找到ClinetProxy,proxy保持了与客户端的连接。
 