# entity图解
>实体包含了id,spaceId,属性Attr map
>dispatcher相当于路由表，查询entity或者actor，向dispatcher问询。
>因此，进一步扁平化，可以认为gate,login，lobby都是game,通过dispatcher互相通信。服务器之间的跳转，简化为场景切换的概念。
>dispatcher之间通过raft算法实现一致性，这样无论连接哪个dispatcher，都能查到entity位于哪个game



```mermaid

graph TB
    a[goworld.run]-->b[game.run]-.生成与dispatcher的连接.->c[dispatchercluster.Initialize]
    c-.注册回调.->c1[_GameDispatcherClientDelegate]
    c1-.写入.->e
    b-->d[GameService.serveRoutine]
    d-.循环读取.->e[packetQueue]
```

## 场景跳转 enterSpace

>e为entity缩写
>d为dispatcher缩写

```mermaid
graph TB
    a[e.EnterSpace]-.查询可迁移gameId.->b[d.handleQuerySpaceGameIDForMigrate]
    b-->c[game]
    c-->d[d handleMigrateRequest]
    d-->e[d block entity的流量]
    e-->f[game 缓存entity数据]
    f-->g[d 迁移数据]
    g-->h[数据发给新game]
    h-->i[新game恢复entity]
    i-->j[d 收到恢复消息]
```


## 问题

* 1属性如何单向和双向同步？

* 2 entity如何call方法传递给client
* 3 client如何call方法传递给entity