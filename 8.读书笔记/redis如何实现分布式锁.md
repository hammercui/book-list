# redis 如何实现分布式锁

## strategy 1

SETNX lock 1 //set if not exist 
EXPIRE lock 10  // 10s后自动过期
DEL lock

问题： setnx与expire不是原子操作，会出现不同步的情况，导致死锁

解决方案：SET lock 1 EX 10 NX 原子操作

问题2： 客户1操作超时，lock被释放掉，客户2加锁，客户1操作完成释放了客户2的锁

## strategy 2
>解锁strategy1锁的权限问题，以及锁超时的续期问题

* 死锁：设置过期时间
* 过期时间评估不好，锁提前过期：守护线程，自动续期
* 锁被别人释放：锁写入唯一标识，释放锁先检查标识，再释放

redlock也是一种分布式锁方案，要点在于>=5个redis单节点，不是主从，形成一个共识网络，类似于区块链。n/2 +1个锁成功，才认为是锁成功了。有点像拜占庭将军问题，总之
还是少数服从多数的一致性方案，或者叫共识方案。

## 总结

setnx以及任何token自增方案，遇到gc或者脑裂现象，都会导致client端以为自己没上锁，但是实际已经上锁了。redis不能保证100%的锁安全，如果追求100%,可以考虑redlock的方案。

# 锁的分类与区别

* 可重入锁:如果一个锁支持一个线程多次加锁，那么这个锁就是可重入的
* 乐观锁：读不设锁，更新数据时上锁，但是通过设置状态或者版本号的形式实现，不会产生死锁。
* 公平锁：线程申请锁,按照申请的先后顺序获得锁
* 自旋转锁：类似于repeatForSure机器，就是未获得锁，不放弃cpu，不断的重试是否能获得锁，cpu紧张时会是巨大的浪费
* Redlock